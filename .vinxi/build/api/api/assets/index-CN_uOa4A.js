import{AsyncLocalStorage as _}from"node:async_hooks";import{H3Event as p,getRequestWebStream as v,getRequestURL as b,eventHandler as x}from"h3";function S(e={}){let t,o=!1;const r=n=>{if(t&&t!==n)throw new Error("Context conflict")};let s;if(e.asyncContext){const n=e.AsyncLocalStorage||globalThis.AsyncLocalStorage;n?s=new n:console.warn("[unctx] `AsyncLocalStorage` is not provided.")}const a=()=>{if(s){const n=s.getStore();if(n!==void 0)return n}return t};return{use:()=>{const n=a();if(n===void 0)throw new Error("Context is not available");return n},tryUse:()=>a(),set:(n,i)=>{i||r(n),t=n,o=!0},unset:()=>{t=void 0,o=!1},call:(n,i)=>{r(n),t=n;try{return s?s.run(n,i):i()}finally{o||(t=void 0)}},async callAsync(n,i){t=n;const u=()=>{t=n},l=()=>t===n?u:void 0;m.add(l);try{const f=s?s.run(n,i):i();return o||(t=void 0),await f}finally{m.delete(l)}}}}function T(e={}){const t={};return{get(o,r={}){return t[o]||(t[o]=S({...e,...r})),t[o]}}}const d=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof global<"u"?global:typeof window<"u"?window:{},h="__unctx__",A=d[h]||(d[h]=T()),E=(e,t={})=>A.get(e,t),g="__unctx_async_handlers__",m=d[g]||(d[g]=new Set);function H(e){let t;const o=R(e),r={duplex:"half",method:e.method,headers:e.headers};return e.node.req.body instanceof ArrayBuffer?new Request(o,{...r,body:e.node.req.body}):new Request(o,{...r,get body(){return t||(t=L(e),t)}})}function I(e){return e.web??(e.web={request:H(e),url:R(e)}),e.web.request}function C(){return U()}const w=Symbol("$HTTPEvent");function $(e){return typeof e=="object"&&(e instanceof p||e?.[w]instanceof p||e?.__is_event__===!0)}function P(e){return function(...t){var o;const r=t[0];if($(r))t[0]=r instanceof p||r.__is_event__?r:r[w];else{if(!((o=globalThis.app.config.server.experimental)!=null&&o.asyncContext))throw new Error("AsyncLocalStorage was not enabled. Use the `server.experimental.asyncContext: true` option in your app configuration to enable it. Or, pass the instance of HTTPEvent that you have as the first argument to the function.");t.unshift(C())}return e(...t)}}const R=P(b),L=P(v);function q(){var e;return E("nitro-app",{asyncContext:!!((e=globalThis.app.config.server.experimental)!=null&&e.asyncContext),AsyncLocalStorage:_})}function U(){const e=q().use().event;if(!e)throw new Error("No HTTPEvent found in AsyncLocalStorage. Make sure you are using the function within the server runtime.");return e}const W=[{path:"/__root",filePath:"/Users/martinrodriguez/personal/guesser-game/src/routes/__root.tsx"},{path:"/",filePath:"/Users/martinrodriguez/personal/guesser-game/src/routes/index.tsx"},{path:"/api/shows/:$id?",filePath:"/Users/martinrodriguez/personal/guesser-game/src/routes/api/shows.$id.ts",$APIRoute:{src:"src/routes/api/shows.$id.ts?pick=APIRoute",build:()=>import("../shows._id.js"),import:()=>import("../shows._id.js")}},{path:"/api/shows",filePath:"/Users/martinrodriguez/personal/guesser-game/src/routes/api/shows.ts",$APIRoute:{src:"src/routes/api/shows.ts?pick=APIRoute",build:()=>import("../shows.js"),import:()=>import("../shows.js")}}],B=["GET","POST","PUT","PATCH","DELETE","OPTIONS","HEAD"];function M(e){return x(async t=>{const o=I(t);return await e({request:o})})}const D=e=>t=>({path:e,methods:t});function N(e,t){const o=e.pathname.split("/").filter(Boolean),r=t.sort((s,a)=>{const n=s.routePath.split("/").filter(Boolean);return a.routePath.split("/").filter(Boolean).length-n.length}).filter(s=>{const a=s.routePath.split("/").filter(Boolean);return o.length>=a.length});for(const s of r){const a=s.routePath.split("/").filter(Boolean),n={};let i=!0;for(let u=0;u<a.length;u++){const l=a[u],f=o[u];if(l.startsWith("$"))if(l==="$"){const c=o.slice(u).join("/");if(c!=="")n["*"]=c,n._splat=c;else{i=!1;break}}else{const c=l.slice(1);n[c]=f}else if(l!==f){i=!1;break}}if(i)return{routePath:s.routePath,params:n,payload:s.payload}}}const y=W.filter(e=>e.$APIRoute);function F(e){const t=[];return e.forEach(o=>{const s=o.path.split("/").filter(Boolean).map(a=>a==="*splat"?"$":a.startsWith(":$")&&a.endsWith("?")?a.slice(1,-1):a).join("/");t.push({routePath:`/${s}`,payload:o})}),t}const k=async({request:e})=>{if(!y.length)return new Response("No routes found",{status:404});if(!B.includes(e.method))return new Response("Method not allowed",{status:405});const t=F(y),o=new URL(e.url,"http://localhost:3000"),r=N(o,t);if(!r)return new Response("Not found",{status:404});let s;try{s=await r.payload.$APIRoute.import().then(i=>i.APIRoute)}catch(i){return console.error("Error importing route file:",i),new Response("Internal server error",{status:500})}if(!s)return new Response("Internal server error",{status:500});const a=e.method,n=s.methods[a];return n?await n({request:e,params:r.params}):new Response("Method not allowed",{status:405})};export{D as a,M as c,k as d};
